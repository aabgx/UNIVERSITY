     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit               ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    10                                  
    11                                  ; our data is declared here (the variables needed by our program)
    12                                  segment data use32 class=data
    13                                      ; ...
    14 00000000 F5                           a db -11
    15 00000001 FD                          b db -3
    16 00000002 FB                          c db -5 
    17 00000003 F9FFFFFF                    e dd -7
    18                                      ;(a+a+b*c*100)/(a+10)+a-e; a,b,c-byte; e-doubleword;  signed
    19 00000007 0000                        aux1 dw 0; sau aux1 resw 1
    20 00000009 0000                        aux2 dw 0; sau aux2 resw 1
    21                                  
    22                                  ; our code starts here
    23                                  segment code use32 class=code
    24                                      start:
    25                                          ; ...
    26                                          ;b*c
    27 00000000 A0[01000000]                    mov al, [b]
    28 00000005 F62D[02000000]                  imul byte [c]   ; AX = b*c
    29 0000000B 66BB6400                        mov bx, 100
    30 0000000F 66F7EB                          imul bx    ; dx:ax = bx*ax = b*c*100
    31                                          
    32 00000012 66A3[07000000]                  mov [aux1], ax
    33 00000018 668915[09000000]                mov [aux2], dx   ; aux2:aux1 = dx :ax = b*c*100
    34                                          
    35 0000001F 8A1D[00000000]                  mov bl, [a]
    36 00000025 021D[00000000]                  add bl, [a] ; bl=a+a
    37 0000002B 660FBEC3                        movsx AX, bl ; Ax = a+a
    38 0000002F 6699                            CWD     ; ax -> DX:AX = a+a
    39                                          
    40                                          ;    dx : ax + 
    41                                           ; aux2 : aux1 
    42                                           
    43 00000031 660305[07000000]                 add ax, [aux1]
    44 00000038 661315[09000000]                 adc dx, [aux2]   ; dx:ax = a+a+b*c*100
    45                                           
    46                                           ;a+10
    47 0000003F 8A1D[00000000]                   mov bl, [a]
    48 00000045 80C30A                           add bl, 10
    49 00000048 660FBEDB                         movsx bx, bl
    50                                           
    51 0000004C 66F7FB                           idiv bx   ; dx:ax/ bx = ax cat si dx rest ; ax = (a+a+b*c*100)/(a+10)
    52                                           
    53 0000004F 8A1D[00000000]                   mov bl, [a]
    54 00000055 660FBEDB                         movsx bx, bl
    55                                           
    56 00000059 6601D8                           add ax, bx  ; ax = a+a+b*c*100)/(a+10)+a
    57                                           
    58 0000005C 0FBFC0                           movsx eax, ax   ; eax = a+a+b*c*100)/(a+10)+a
    59 0000005F 2B05[03000000]                   sub eax, [e]  ; eax = a+a+b*c*100)/(a+10)+a-e
    60                                           
    61                                          
    62                                          
    63                                      
    64                                          ; exit(0)
    65 00000065 6A00                            push    dword 0      ; push the parameter for exit onto the stack
    66 00000067 FF15[00000000]                  call    [exit]       ; call exit to terminate the program
